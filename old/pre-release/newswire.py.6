from  Tkinter import *

import sys
import os
import time
import rssparser
import rssfinder
import timeoutsocket
import webbrowser
import pickle

config = {}

# Program default values:
config['mode']          = "gui"
config['progname']      = "NewsFeed"
config['refresh_every'] = 15		# Refresh interval in minutes
config['maxtime']       = 30		# Maximum time (in days) to keep items

config_file = os.path.join(os.path.expanduser("~"),".newsfeed")

newsfeeds = []

initial = [
  ("Wired News", "http://www.wired.com/news_drop/netcenter/netcenter.rdf"),
  ("NYT News",   "http://www.newsisfree.com/HPE/xml/feeds/64/164.xml"),
  ("Slashdot",   "http://slashdot.org/slashdot.rdf"),
  ("Freshmeat",  "http://freshmeat.net/backend/fm.rdf"),
  ("Python News","http://www.python.org/channews.rdf"),
  ("CNN News",   "http://www.newsisfree.com/HPE/xml/feeds/96/696.xml."),
  ("BBC News",   "http://www.bbc.co.uk/syndication/feeds/news/ukfs_news/world/rss091.xml")
]

class ContentItem:
	"A channel content class."
	def __init__(s, title, descr, link, date):
		s.title  = title
		s.descr  = descr
		s.link   = link
		s.date   = date
		s.unread = 1
	def show(s, num):
		"Print item info for text interface."
		print "[%2u] %s" % (num, s.get_title())
		if s.descr != "(none)":
			print s.descr
		print "%80s" % s.link
	def get_title(s):
		"Return title of item. Put in parentheses if already read."
		if s.unread:
			return s.title
		else:
			return "  (" + s.title + ")"

class NewsWire:
	"A channel class that stores its content in s.contents"
	def __init__(s, url = "", site = "", name = "", homeurl = ""):
		if url != "(find)": s.url = url
		elif site != "":
			tmp = rssfinder.getFeeds(site)
			print len(tmp), "feeds found."
			if len(tmp) < 1: raise IOError
			s.url = tmp[0]
			print "Using RSS feed at %s." % s.url
		else: raise IOError
		s.name       = name
		s.homeurl    = homeurl
		s.result     = {}
		s.content    = []
		s.headlines  = {}
		s.num_unread = 0

	def get_name(s):
		"Return newsfeed name, optionally with number of unread items."
		if not s.content: return "  [" + s.name + "]"
		s.num_unread = s.get_unread()
		if s.num_unread:
			return s.name + " (" + str(s.num_unread) + ")"
		else:
			return s.name

	def get_unread(s):
		"Return number of unread items in newsfeed."
		i = 0
		for item in s.content:
			if item.unread: i = i + 1
		return i

	def get_news(s, refresh=0):
		"Get news items from the Web and decode to instance variables."
		if s.content == [] or refresh and not s.url == "":
			#Parse the data, returns a dictionary:
			s.result  = rssparser.parse(s.url)
			s.title   = s.result['channel'].get('title', "").strip()
			s.date    = s.result['channel'].get('date', "").strip()
			newcontent = []
			for item in s.result['items']:
				#Each item is a dictionary mapping properties to values
				title = item.get('title', "(none)")
				if title not in s.headlines.keys():
					#print s.headlines.keys()
					s.headlines[title] = time.time()
					descr = item.get('description', "No description available.")
					link  = item.get('link', "(none)")
					date  = item.get('date', "")
					if not date: date = s.date
					newcontent.append(ContentItem(title, descr, link, date))
			s.content = newcontent + s.content
			for i in s.headlines.keys():
				if (s.headlines[i] - time.time()) / 86400 > config['maxtime']:
						for j in s.content:
							if j.title ==  s.headlines[i]:
								del j
								del s.headlines[i]
 
	def print_news(s):
		"Print items to screen and open selected item's URI in browser."
		s.get_news()
		if s.content == []:
			print "\nCurrently no newsfeed. Please try again later."
			return
		print "\n%80s" % s.date
		if s.name != "": print s.name, "--",
		print s.title
		for i in range(40): print "=",
		print
		i = 1
		for item in s.content:
			item.show(i)
			i = i + 1
		while 1:
			try:
				topic = input("\nPlease select your topic (\"0\" to go back to menu): ")
			except SyntaxError:
				continue
			if 0 < topic <= len(s.content):
				s.open_news(s.content[topic-1])
			else: break

	def open_news(s, item):
		"Open news item in browser."
		try:
			webbrowser.open(item.link)
		except webbrowser.Error:
			print "Error: Opening browser failed."
		else:
			item.unread = 0

def add_feeds(obj):
	"Accept a list of tuples and add them to the global newsfeed pool."
	global newsfeeds
	try:
		newsfeeds, config = pickle.load(open(config_file, 'r'))
	except:
		for i in obj:
			try:
				newsfeeds.append(NewsWire(i[1], name=i[0]))
			except (IOError, timeoutsocket.Timeout):
				print "Error: Could not find a suitable newsfeed."

def quit():
	"Save defaults and exit Program."
	try:
		pickle.dump((newsfeeds, config), open(config_file, 'w'))
	except Exception:
		pass
	sys.exit(0)

def text_interface():
	"Present the user with a simple textual interface to the RSS feeds."
	if len(newsfeeds):
		while 1:
			print "\nAvailable newsfeeds:\n"
			for i in range(len(newsfeeds)):
				print "[%2u] %s" % (i+1, newsfeeds[i].get_name())
			try:
				feed = input("\nPlease select your feed (\"0\" to quit): ")
			except SyntaxError:
				continue
			if 0 < feed <= len(newsfeeds):
				try:
					newsfeeds[feed-1].print_news()
				except timeoutsocket.Timeout:
					print "Operation timed out. ",
					print "Please choose a different feed..."
			else: quit()

class TkApp:
	"GUI class for use with the Tk interface."
	def __init__(s, parent):
		s.sel_f  = 0
		s.sel_t  = 0
		s.parent = parent
		s.percent           = 0		# Progress bar value
		s.refresh_feeds     = []	# Feeds to update
		s.num_refresh_feeds = 0 	# Number of feeds to update
		s.u_time            = time.time()	# Time of last update
		s.refresh_now       = 0

		#Frames:
		s.f1 = Frame(parent)
		s.f1.pack(side = TOP, expand = 0, fill = X)
		s.f2 = Frame(parent)
		s.f2.pack(side = BOTTOM, expand = 1, fill = BOTH)
		s.f3 = Frame(s.f1)
		s.f3.pack(side = LEFT, expand = 1, fill = BOTH)
		s.f4 = Frame(s.f1)
		s.f4.pack(side = RIGHT, expand = 1, fill = BOTH)
		s.f5 = Frame(s.f2)
		s.f5.pack(side = LEFT, expand = 0, fill = Y)
		s.f6 = Frame(s.f2)
		s.f6.pack(side = RIGHT, expand = 1, fill = BOTH)
		s.f7 = Frame(s.f6)
		s.f7.pack(side = TOP, expand = 1, fill = BOTH)
		s.f8 = Frame(s.f6)
		s.f8.pack(side = BOTTOM, expand = 1, fill = BOTH)

		#Buttons:
		s.b_refresh = Button(s.f3, text = "Refresh Now", command = s.refresh)
		s.b_refresh.pack(side = LEFT)
		s.b_info = Button(s.f3, text = "Edit Channel", command = s.info)
		s.b_info.pack(side = LEFT)
		s.b_sub = Button(s.f3, text = "Subscribe", command = s.sub)
		s.b_sub.pack(side = LEFT)
		s.b_unsub = Button(s.f3, text = "Unsubscribe", command = s.unsub)
		s.b_unsub.pack(side = LEFT)

		s.b_open = Button(s.f4, text = "Open Article", command = s.open)
		s.b_open.pack(side = RIGHT)
		s.b_allread = Button(s.f4, text = "Mark All As Read", command = s.mark_all_as_read)
		s.b_allread.pack(side = RIGHT)
		s.b_next = Button(s.f4, text = "Next Unread", command = s.next)
		s.b_next.pack(side = RIGHT)

		#Text:
		s.lb = Listbox(s.f5, selectmode = SINGLE)
		for i in newsfeeds:
			s.lb.insert(END, i.get_name())
		s.lb.pack(side = TOP, expand = 1, fill = BOTH)

		s.f_ud = Frame(s.f5)
		s.f_ud.pack(side = TOP, expand = 0, fill = X)
		s.b_up = Button(s.f_ud, text = "Move Up", command = s.up)
		s.b_up.pack(side = LEFT)
		s.b_dn = Button(s.f_ud, text = "Move Down", command = s.down)
		s.b_dn.pack(side = RIGHT)

		s.pbar = Canvas(s.f5, width = 120, height = 20)
		s.pbar.pack(side = BOTTOM)
		s.pbar.create_rectangle(0, 4, 100, 14, fill = "white")
		s.pbarline = s.pbar.create_rectangle(0, 4, 0, 14, fill = "blue")

		s.r1b_scr = Scrollbar(s.f7)
		s.r1b_scr.pack(side = RIGHT, fill = Y)
		s.r1b = Listbox(s.f7, selectmode = SINGLE, yscrollcommand = s.r1b_scr.set)
		for i in newsfeeds[0].content:
			s.r1b.insert(END, i.get_title())
		s.r1b.pack(side = TOP, expand = 1, fill = BOTH)
		s.r1b_scr.config(command = s.r1b.yview)
		s.r2b = Text(s.f8, wrap = WORD)
		s.r2b.config(state = DISABLED)
		s.r2b.pack(side = BOTTOM, expand = 1, fill = BOTH)

		parent.after(250, s.beat)

	def draw_bar(s):
		"Draw a progress bar while updating the feeds."
		if s.percent > 99 or s.percent < 0: s.percent = 0
		s.pbar.coords(s.pbarline, 0, 4, int(s.percent), 14)

	def _update_feed_list(s):
		"Update the list of feeds."
		s.lb.delete(0, END)
		for i in newsfeeds:
			s.lb.insert(END, i.get_name())

	def change_feed(s, feed = 0, savescroll = 0):
		"Switch to a different feed."
		s.sel_f = int(feed)
		s.parent.title(config['progname'] + " -- " + newsfeeds[s.sel_f].name)
		scroll = int(.5 + s.r1b.yview()[0] * (len(newsfeeds[s.sel_f].content) - 1))
		s.r1b.delete(0, END)
		newsfeeds[s.sel_f].get_news()
		s._update_feed_list()
		for i in newsfeeds[s.sel_f].content:
			s.r1b.insert(END, i.get_title())
		if savescroll: s.r1b.yview(scroll)
		else: s.change_topic(None, 0)

	def change_topic(s, event, topic = -1):
		"Switch to a different topic."
		if not len(newsfeeds[s.sel_f].content): return
		if topic < 0:
			try:
				s.sel_t = int(s.r1b.curselection()[0])
			except Exception:
				s.sel_t = 0
		else:
			s.sel_t = int(topic)
		newsfeeds[s.sel_f].content[s.sel_t].unread = 0
		s.change_feed(feed = s.sel_f, savescroll = 1)
		s.r2b.config(state = NORMAL)
		s.r2b.delete(1.0, END)
		txt = "%80s\n%s\n\n%s\n\n%80s" % (newsfeeds[s.sel_f].content[s.sel_t].date, newsfeeds[s.sel_f].content[s.sel_t].title, newsfeeds[s.sel_f].content[s.sel_t].descr, newsfeeds[s.sel_f].content[s.sel_t].link)
		s.r2b.insert(END, txt)
	#	mywin = Toplevel(s.r2b)
	#	mywin.geometry("50x20")
	#	s.r2b.window_create(END, align = BASELINE, window = mywin, stretch = OFF)
		s.r2b.config(state = DISABLED)

	def next(s):
		"Jump to next unread item."
		#Look in this feed:
		for i in range(s.sel_t, len(newsfeeds[s.sel_f].content)):
			if newsfeeds[s.sel_f].content[i].unread:
				s.sel_t = i
				s.change_topic(None, topic = i)
				return
		#Look in feeds below the current one:
		for i in range(s.sel_f, len(newsfeeds)):
			if newsfeeds[i].num_unread:
				s.change_feed(feed = i)
				s.sel_t = 0
				s.next()
				return
		#Look in feeds above the current one:
		for i in range(0, s.sel_f):
			if newsfeeds[i].num_unread:
				s.change_feed(feed = i)
				s.sel_t = 0
				s.next()
				return

	def mark_all_as_read(s):
		"Mark all items in current channel as read."
		for i in newsfeeds[s.sel_f].content:
			i.unread = 0
		s.change_feed(feed = s.sel_f)

	def open(s):
		"Open news item link in web browser."
		if not len(newsfeeds[s.sel_f].content): return
		newsfeeds[s.sel_f].open_news(newsfeeds[s.sel_f].content[s.sel_t])
		s.change_feed(feed = s.sel_f, savescroll = 1)

	def refresh(s):
		"Refresh all newsfeeds."
		if s.refresh_now < 1:
			s.refresh_now = 1

	def info(s):
		"Display editable info about current channel."
		try: tmp = s.infowin.geometry()
		except (Exception, TclError): pass
		else: return

		s.infowin = Toplevel()
		s.infosel = s.sel_f
		s.infowin.title("Subscription Info")
		s.infowin.geometry("600x180")

		f1 = Frame(s.infowin, borderwidth = 10)
		f1.pack(side = TOP)
		f2 = Frame(f1)
		f2.pack(side = LEFT)
		l1 = Label(f2, text = "Name:")
		l1.pack()
		f3 = Frame(f1)
		f3.pack(side = RIGHT)
		s.e1 = Entry(f3, width = 65)
		s.e1.insert(END, newsfeeds[s.sel_f].name)
		s.e1.pack(side = LEFT)

		f4 = Frame(s.infowin, borderwidth = 10)
		f4.pack(side = TOP)
		f5 = Frame(f4)
		f5.pack(side = LEFT)
		l2 = Label(f5, text = "Home:")
		l2.pack()
		f6 = Frame(f4)
		f6.pack(side = RIGHT)
		s.e2 = Entry(f6, width = 65)
		s.e2.insert(END, newsfeeds[s.sel_f].homeurl)
		s.e2.pack(side = LEFT)

		f7 = Frame(s.infowin, borderwidth = 10)
		f7.pack(side = TOP)
		f8 = Frame(f7)
		f8.pack(side = LEFT)
		l3 = Label(f8, text = "  RSS:")
		l3.pack()
		f9 = Frame(f7)
		f9.pack(side = RIGHT)
		s.e3 = Entry(f9, width = 65)
		s.e3.insert(END, newsfeeds[s.sel_f].url)
		s.e3.pack(side = LEFT)

		b1 = Button(s.infowin, text = "Update", command = s.update)
		b1.pack()

	def update(s):
		"Update the channel information."
		newsfeeds[s.infosel].name    = s.e1.get()
		newsfeeds[s.infosel].homeurl = s.e2.get()
		newsfeeds[s.infosel].url     = s.e3.get()
		s.infowin.destroy()
		s.change_feed(feed = s.sel_f, savescroll = 1)

	def sub(s):
		"Subscribe to new channel."
		if s.refresh_now: return
		newsfeeds.append(NewsWire(name = "New Channel"))
		s.change_feed(feed = len(newsfeeds) - 1)
		s.info()

	def unsub(s):
		"Remove current channel."
		if s.refresh_now: return
		if len(newsfeeds) == 1: return
		del newsfeeds[s.sel_f]
		if s.sel_f == len(newsfeeds) and len(newsfeeds): s.sel_f = s.sel_f - 1
		s.change_feed(feed = s.sel_f)

	def up(s):
		"Move a channel up in list."
		if s.sel_f:
			newsfeeds[s.sel_f], newsfeeds[s.sel_f - 1] = newsfeeds[s.sel_f - 1], newsfeeds[s.sel_f]
			s.change_feed(feed = s.sel_f - 1, savescroll = 1)

	def down(s):
		"Move a channel down in list."
		if s.sel_f < len(newsfeeds) - 1:
			newsfeeds[s.sel_f], newsfeeds[s.sel_f + 1] = newsfeeds[s.sel_f + 1], newsfeeds[s.sel_f]
			s.change_feed(feed = s.sel_f + 1, savescroll = 1)

	def beat(s):
		"Look if any updating of feeds is necessary."
		if s.refresh_now == 1:
			for i in newsfeeds:
				s.refresh_feeds.append(i)
			s.num_refresh_feeds = s.num_refresh_feeds + len(newsfeeds)
			s.u_time            = time.time()
			s.refresh_now = 2
		if len(s.refresh_feeds) and s.num_refresh_feeds:
			s.percent = 100 - 100 * (len(s.refresh_feeds) - 1) / s.num_refresh_feeds
			s.draw_bar()
			s.refresh_feeds.pop(0).get_news(refresh = 1)
			s.change_feed(feed = s.sel_f)
		else:
			s.refresh_now = 0
			s.percent = 0
			s.draw_bar()

		if (time.time() - s.u_time) / 60 > config['refresh_every']:
			s.u_time            = time.time()
			s.refresh_now       = 1

		if len(s.lb.curselection()) and s.lb.curselection()[0] != s.sel_f:
			s.change_feed(feed = s.lb.curselection()[0])
		if len(s.r1b.curselection()) and s.r1b.curselection()[0] != s.sel_t:
			s.change_topic(None, topic = s.r1b.curselection()[0])

		s.parent.after(50, s.beat)

def gui_interface():
	"Tk interface routine."
	root = Tk()

	root.title(config['progname'] + " -- " + newsfeeds[0].name)
	root.geometry("800x500")

	app = TkApp(root)

	root.protocol("WM_DELETE_WINDOW", quit)

	root.mainloop()

def main():
	"Main Program. Start either textual or graphical interface."
	add_feeds(initial)
	if config['mode'] == "text":
		text_interface()
	else:
		gui_interface()

if __name__ == '__main__': main()

